import numpy as np

#=================================================
# Funciones traducidas y adaptadas de FSELIB
# http://dehesa.freeshell.org/FSELIB/
#=================================================

def lobatto(i=6):

#=================================================
# Zeros of the ith-degree Lobatto polynomial
#
# This table contains values for i = 1, 2, ..., 6
# The default value is i=6
#=================================================

    if(i>6):
        print('Data is not available; Will take i=6')
        i=6

    Z = np.zeros(i)

    if(i==1):
        Z[0] = 0.0

    elif(i==2):
        Z[0] = -1.0/np.sqrt(5.0)
        Z[1] = -Z[0]

    elif(i==3):
        Z[0] = -np.sqrt(3.0/7.0)
        Z[1] = 0.0
        Z[2] = -Z[0]

    elif(i==4):
        Z[0] = -0.76505532392946
        Z[1] = -0.28523151648064
        Z[2] = -Z[1]
        Z[3] = -Z[0]

    elif(i==5):
        Z[0] = -0.83022389627857
        Z[1] = -0.46884879347071
        Z[2] = 0.0
        Z[3] = -Z[1]
        Z[4] = -Z[0]

    elif(i==6):
        Z[0] = -0.87174014850961
        Z[1] = -0.59170018143314
        Z[2] = -0.20929921790248
        Z[3] = -Z[2]
        Z[4] = -Z[1]
        Z[5] = -Z[0]

    return Z


def emm(N=6):

#================================================
# dimensionless element mass matrix for
# Nth-order polynomial expansion
#
# values are given for: N in 1 - 6
#================================================

    if(N==1):
        elm_mm =  np.array((
        (2/3, 1/3), 
        (1/3, 2/3)))

    elif(N==2):
        elm_mm =  np.array((
        (0.26666666666667, 0.13333333333333, -0.06666666666667),
        (0.13333333333333, 1.06666666666667, 0.13333333333333),
        (-0.06666666666667, 0.13333333333333, 0.26666666666667)))

    elif(N==3):
        elm_mm = np.array((
        (0.14285714285714, 0.05323971374999, -0.05323971374999, 0.02380952380952),
        (0.05323971375000, 0.71428571428571, 0.11904761904762, -0.05323971374999),
        (-0.05323971374999, 0.11904761904762, 0.71428571428571, 0.05323971375000),
        (0.02380952380952, -0.05323971374999, 0.05323971375000, 0.14285714285714)))

    elif(N==4):
        elm_mm = np.array((
        (0.08888888888889, 0.02592592592592, -0.02962962962963, 0.02592592592593, -0.01111111111111),
        (0.02592592592592, 0.48395061728395, 0.06913580246913, -0.06049382716049, 0.02592592592593),
        (-0.02962962962963, 0.06913580246913, 0.63209876543211, 0.06913580246913, -0.02962962962963),
        (0.02592592592593, -0.06049382716049, 0.06913580246913, 0.48395061728395, 0.02592592592592),
        (-0.01111111111111, 0.02592592592593, -0.02962962962963, 0.02592592592592, 0.08888888888889)))

    elif(N==5):
        elm_mm = np.array((
       (0.06060606060606,   0.01444043443670,  -0.01748448154180,   0.01748448154179,  -0.01444043443670,   0.00606060606061),
       (0.01444043443670,   0.34406814208894,   0.04165977904505,  -0.04165977904505,   0.03440681420889,  -0.01444043443670),
      (-0.01748448154180,   0.04165977904505,   0.50441670639590,   0.05044167063958,  -0.04165977904505,   0.01748448154179),
       (0.01748448154179,  -0.04165977904505,   0.05044167063958,   0.50441670639590,   0.04165977904505,  -0.01748448154180),
      (-0.01444043443670,   0.03440681420889,  -0.04165977904505,   0.04165977904505,   0.34406814208894,   0.01444043443670),
       (0.00606060606061,  -0.01444043443670,   0.01748448154179,  -0.01748448154180,   0.01444043443670,   0.06060606060606)))

    else: # Incorpora los casos en que N >= 6
        elm_mm = np.array((
       (0.04395604395604,   0.00883182542984,  -0.01102962762764,   0.01172161172161,  -0.01102962762764,   0.00883182542984,  -0.00366300366300),
       (0.00883182542984,   0.25553173602605,   0.02659340659341,  -0.02826184137547,   0.02659340659341,  -0.02129431133550,   0.00883182542984),
      (-0.01102962762764,   0.02659340659341,   0.39853419803987,   0.03529480840844,  -0.03321118316999,   0.02659340659341,  -0.01102962762764),
       (0.01172161172161,  -0.02826184137547,   0.03529480840844,   0.45010989010988,   0.03529480840844,  -0.02826184137547,   0.01172161172161),
      (-0.01102962762764,   0.02659340659341,  -0.03321118316999,   0.03529480840844,   0.39853419803987,   0.02659340659341,  -0.01102962762764),
       (0.00883182542984,  -0.02129431133550,   0.02659340659341,  -0.02826184137547,   0.02659340659341,   0.25553173602605,   0.00883182542984),
      (-0.00366300366300,   0.00883182542984,  -0.01102962762764,   0.01172161172161,  -0.01102962762764,   0.00883182542984,   0.04395604395604)))

    return elm_mm


def edm(N=6):

#=======================================
# spectral element diffusion matrix for
# an Nth-order polynomial expansion.
#
# N in 1 - 6
#=======================================

    if(N==1):
        elm_dm = np.array(((0.5, -0.5),(-0.5, 0.5)))

    elif(N==2):
        elm_dm = np.array((
            (1.16666666666667, -1.33333333333333, 0.16666666666667),
            (-1.33333333333333, 2.66666666666667, -1.33333333333333),
            (0.16666666666667, -1.33333333333333, 1.16666666666667)))

    elif(N==3):
        elm_dm = np.array((
            (2.16666666666667, -2.43920915260403, 0.35587581927070, -0.08333333333333),
            (-2.43920915260403, 4.16666666666667, -2.08333333333333, 0.35587581927070),
            (0.35587581927070, -2.08333333333333, 4.16666666666667, -2.43920915260404),
            (-0.08333333333333, 0.35587581927070, -2.43920915260404, 2.16666666666667)))

    elif(N==4):
        elm_dm = np.array((
            (3.50000000000000, -3.91288507544030, 0.53333333333333, -0.17044825789303, 0.05000000000000),
            (-3.91288507544030, 6.35185185185185, -2.90370370370371, 0.63518518518519, -0.17044825789303),
            (0.53333333333333, -2.90370370370371, 4.74074074074074, -2.90370370370371, 0.53333333333333),
            (-0.17044825789303, 0.63518518518519, -2.90370370370371, 6.35185185185185, -3.91288507544030),
            (0.05000000000000, -0.17044825789303, 0.53333333333333, -3.91288507544030, 3.50000000000000)))

    elif(N==5):
        elm_dm = np.array((
            (5.16666666666647,  -5.75534978755293,   0.75291274743628,  -0.23286955119427,   0.10197325797781,  -0.03333333333336),
            (-5.75534978755293,   9.12668826478755,  -3.98085223985198,   0.83085223985201,  -0.32331173521247,   0.10197325797781),
            (0.75291274743628,  -3.98085223985198,   6.03997840187932,  -3.41002159812136,   0.83085223985201,  -0.23286955119427),
            (-0.23286955119427,   0.83085223985201,  -3.41002159812136,   6.03997840187932,  -3.98085223985198,   0.75291274743628),
            (0.10197325797781,  -0.32331173521247,   0.83085223985201,  -3.98085223985198,   9.12668826478755,  -5.75534978755293),
            (-0.03333333333336,   0.10197325797781,  -0.23286955119427,   0.75291274743628,  -5.75534978755293,   5.16666666666647)))

    else: # Incorpora los casos en que N >= 6
        elm_dm = np.array((
            (7.16666666666692, -7.96655757431697, 1.01647769632621, -0.30476190476184, 0.13291684274811, -0.06855125047193, 0.02380952380950),
            (-7.96655757431697, 12.47251984118633, -5.29457208031436, 1.06606416109113, -0.40971363397094, 0.20081053679675, -0.06855125047193),
            (1.01647769632621, -5.29457208031436, 7.74748015881332, -4.17463558966276, 0.98204660606043, -0.40971363397094, 0.13291684274811),
            (-0.30476190476184, 1.06606416109113, -4.17463558966276, 6.82666666666694, -4.17463558966276, 1.06606416109113, -0.30476190476184),
            (0.13291684274811, -0.40971363397094, 0.98204660606043, -4.17463558966276, 7.74748015881332, -5.29457208031436, 1.01647769632621),
            (-0.06855125047193, 0.20081053679675, -0.40971363397094, 1.06606416109113, -5.29457208031436, 12.47251984118632, -7.96655757431697),
            (0.02380952380950, -0.06855125047193, 0.13291684274811, -0.30476190476184, 1.01647769632621, -7.96655757431697, 7.16666666666691)))

    return elm_dm


#=================================================
# Funciones nuevas implementadas
#=================================================

def genNodes(Ne,Np,xe):

#=================================================
# Genera los nodos de interpolacion segun el
# numero de elementos y sus ordenes. Esta es la
# numeracion local de los nodos: (l,i)
# 
# Ne = Np.size
# max(Np) < 6
#=================================================

    if(Ne != Np.size):
        raise NameError('La cantidad de elementos no coincide con el orden')

    xint = np.zeros((Ne,max(Np)+1))
    for l in range(Ne):
        mid = 0.5 * (xe[l+1]+xe[l])
        dis = 0.5 * (xe[l+1]-xe[l])
        xint[l,0] = xe[l]
        vals = lobatto(Np[l]-1)
        xint[l,1:Np[l]] = mid + vals*dis
        xint[l,Np[l]] = xe[l+1]
    return xint


def genConn(Ne,Np,xint):

#=================================================
# Genera los vectores de numeracion global y la
# matriz de conectividad
#
# max(Np) < 6
#=================================================

    xglob = np.zeros(np.sum(Np)+1)
    C = np.zeros((Ne,max(Np)+1),int)

    # Contador Global
    cont = 0
    for l in range(Ne):
        C[l,0:Np[l]+1] = np.arange(cont,cont+Np[l]+1)
        xglob[cont:cont+Np[l]+1] = xint[l,0:Np[l]+1]
        cont+=Np[l]
    return xglob, C


def matDiff(Ne,Np,xe,xglob,C,U0,U1,mu=1,s=lambda x: 0):

#=================================================
# Genera la matriz de difusion/rigidez y el vector
# del lado derecho del sistema sujeto a condicio-
# nes de Dirichlet en ambos extremos
#
# max(Np) < 6
#=================================================

    Ng = xglob.size
    Mat_dif = np.zeros((Ng,Ng))
    vec_b = np.zeros(Ng)
    s = np.vectorize(s)

    for l in range(Ne):
        N = Np[l]
        h = xe[l+1]-xe[l]
        elm_mm = 0.5*h*emm(N)
        elm_dm = 2.0*edm(N)/h

        Mat_dif[C[l,0]:C[l,N]+1,C[l,0]:C[l,N]+1] += elm_dm
        vec_b[C[l,0:N+1]] += np.dot(elm_mm,s(xglob[C[l,0:N+1]]))/mu

    # Implementa las condiciones de frontera de Dirichlet

    # Extremo derecho
    # los valores de N, h y elm_dm ya corresponden a los del ultimo nodo
    vec_b[C[Ne-1,0:N+1]] -= elm_dm[0:N+1,N]*U1

    # Extremo izquierdo
    N = Np[0]
    h = xe[1]-xe[0]
    elm_dm = 2.0*edm(Np[0])/h
    vec_b[C[0,0:N+1]] -= elm_dm[0:N+1,0]*U0
    
    return Mat_dif, vec_b
